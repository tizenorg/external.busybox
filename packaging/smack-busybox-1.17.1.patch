
Smack updates for busybox-1.17.1

---
 
 Config.in             |    9 ++
 Makefile              |    1 
 coreutils/id.c        |   26 +++++-
 coreutils/ls.c        |   28 ++++++
 coreutils/stat.c      |   87 ++++++++++++++++----
 findutils/find.c      |   31 +++++++
 include/applets.src.h |    4 
 include/libbb.h       |   21 ++++
 include/usage.src.h   |   30 ++++++-
 libbb/Kbuild.src      |    1 
 libbb/messages.c      |    3 
 libbb/procps.c        |    6 +
 libbb/smack_common.c  |  178 ++++++++++++++++++++++++++++++++++++++++++
 loginutils/adduser.c  |   13 ++-
 loginutils/login.c    |    8 +
 loginutils/su.c       |    8 +
 loginutils/sulogin.c  |    6 +
 miscutils/crond.c     |   11 ++
 miscutils/crontab.c   |   13 +++
 procps/ps.c           |   48 +++++++++--
 smack/Config.src      |   40 +++++++++
 smack/Kbuild.src      |   14 +++
 smack/newsmack.c      |   61 ++++++++++++++
 smack/smackcipso.c    |  119 ++++++++++++++++++++++++++++
 smack/smackenabled.c  |   17 ++++
 smack/smackload.c     |   93 +++++++++++++++++++++
 26 files changed, 844 insertions(+), 32 deletions(-)

diff -uprN busybox-1.17.1/Config.in busybox-1.17.1-smack/Config.in
--- busybox-1.17.1/Config.in	2010-07-24 15:12:56.000000000 -0700
+++ busybox-1.17.1-smack/Config.in	2011-08-17 15:27:12.889107702 -0700
@@ -370,6 +370,14 @@ config SELINUX
 
 	  Most people will leave this set to 'N'.
 
+config SMACK
+	bool "Support Smack"
+	default n
+	help
+	  Enable support for Smack in applets ls, ps, and id.  Also provide
+	  the option of compiling in Smack applets.
+
+
 config FEATURE_PREFER_APPLETS
 	bool "exec prefers applets"
 	default n
@@ -739,4 +747,5 @@ source procps/Config.in
 source runit/Config.in
 source selinux/Config.in
 source shell/Config.in
+source smack/Config.in
 source sysklogd/Config.in
diff -uprN busybox-1.17.1/coreutils/id.c busybox-1.17.1-smack/coreutils/id.c
--- busybox-1.17.1/coreutils/id.c	2010-07-05 19:25:53.000000000 -0700
+++ busybox-1.17.1-smack/coreutils/id.c	2011-08-17 15:27:12.889107702 -0700
@@ -34,6 +34,9 @@ enum {
 #if ENABLE_SELINUX
 	JUST_CONTEXT    = (1 << 5),
 #endif
+#if ENABLE_SMACK
+	JUST_LABEL      = (1 << 5),
+#endif
 };
 
 static int print_common(unsigned id, const char *name, const char *prefix)
@@ -116,11 +119,15 @@ int id_main(int argc UNUSED_PARAM, char
 #if ENABLE_SELINUX
 	security_context_t scontext = NULL;
 #endif
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+#endif
 	/* Don't allow -n -r -nr -ug -rug -nug -rnug -uZ -gZ -GZ*/
 	/* Don't allow more than one username */
 	opt_complementary = "?1:u--g:g--u:G--u:u--G:g--G:G--g:r?ugG:n?ugG"
-			 IF_SELINUX(":u--Z:Z--u:g--Z:Z--g:G--Z:Z--G");
-	opt = getopt32(argv, "rnugG" IF_SELINUX("Z"));
+			 IF_SELINUX(":u--Z:Z--u:g--Z:Z--g:G--Z:Z--G")
+			 IF_SMACK(":u--Z:Z--u:g--Z:Z--g:G--Z:Z--G");
+	opt = getopt32(argv, "rnugG" IF_SELINUX("Z") IF_SMACK("Z"));
 
 	username = argv[optind];
 	if (username) {
@@ -187,6 +194,10 @@ int id_main(int argc UNUSED_PARAM, char
 				printf(" context=%s", scontext);
 		}
 #endif
+#if ENABLE_SMACK
+		if (smack_from_proc(-1, smack, sizeof(smack)) == 0)
+			printf(" label=%s", smack);
+#endif
 	} else if (opt & PRINT_REAL) {
 		euid = ruid;
 		egid = rgid;
@@ -205,6 +216,17 @@ int id_main(int argc UNUSED_PARAM, char
 		}
 		fputs(scontext, stdout);
 	}
+#endif
+#if ENABLE_SMACK
+	else if (opt & JUST_LABEL) {
+		if (username || smack_from_proc(-1, smack, sizeof(smack)) < 0) {
+			bb_error_msg_and_die("can't get process label%s",
+				username ? " for a different user" : "");
+		}
+		fputs(smack, stdout);
+	}
+#endif
+#if ENABLE_SELINUX
 	/* freecon(NULL) seems to be harmless */
 	if (ENABLE_FEATURE_CLEAN_UP)
 		freecon(scontext);
diff -uprN busybox-1.17.1/coreutils/ls.c busybox-1.17.1-smack/coreutils/ls.c
--- busybox-1.17.1/coreutils/ls.c	2010-07-05 19:25:53.000000000 -0700
+++ busybox-1.17.1-smack/coreutils/ls.c	2011-08-17 16:23:44.839147638 -0700
@@ -141,6 +141,7 @@ static const char ls_options[] ALIGN1 =
 	IF_FEATURE_LS_RECURSIVE("R")     /* 1, 25 */
 	IF_FEATURE_HUMAN_READABLE("h")   /* 1, 26 */
 	IF_SELINUX("KZ") /* 2, 28 */
+	IF_SMACK("KZ") /* 2, 28 */
 	IF_FEATURE_AUTOWIDTH("T:w:") /* 2, 30 */
 	;
 enum {
@@ -165,6 +166,7 @@ enum {
 		+ 1 * ENABLE_FEATURE_LS_RECURSIVE
 		+ 1 * ENABLE_FEATURE_HUMAN_READABLE
 		+ 2 * ENABLE_SELINUX
+		+ 2 * ENABLE_SMACK
 		+ 2 * ENABLE_FEATURE_AUTOWIDTH,
 	OPT_color = 1 << OPTBIT_color,
 };
@@ -191,6 +193,7 @@ static const unsigned opt_flags[] = {
 	0,                          /* Q (quote filename) - handled via OPT_Q */
 	DISP_HIDDEN,                /* A */
 	ENABLE_SELINUX * LIST_CONTEXT, /* k (ignored if !SELINUX) */
+	ENABLE_SMACK * LIST_CONTEXT, /* k (ignored if !SMACK) */
 #if ENABLE_FEATURE_LS_TIMESTAMPS
 	TIME_CHANGE | (ENABLE_FEATURE_LS_SORTFILES * SORT_CTIME),   /* c */
 	LIST_FULLTIME,              /* e */
@@ -216,10 +219,10 @@ static const unsigned opt_flags[] = {
 #if ENABLE_FEATURE_HUMAN_READABLE
 	LS_DISP_HR,                 /* h */
 #endif
-#if ENABLE_SELINUX
+#if ENABLE_SELINUX || ENABLE_SMACK
 	LIST_MODEBITS|LIST_NLINKS|LIST_CONTEXT|LIST_SIZE|LIST_DATE_TIME, /* K */
 #endif
-#if ENABLE_SELINUX
+#if ENABLE_SELINUX || ENABLE_SMACK
 	LIST_MODEBITS|LIST_ID_NAME|LIST_CONTEXT, /* Z */
 #endif
 	(1U<<31)
@@ -239,6 +242,7 @@ struct dnode {
 	smallint fname_allocated;
 	struct stat dstat;      /* the file stat info */
 	IF_SELINUX(security_context_t sid;)
+	IF_SMACK(char xattr[SMACKBUFFSIZE];)
 };
 
 struct globals {
@@ -288,6 +292,10 @@ static struct dnode *my_stat(const char
 	struct stat dstat;
 	struct dnode *cur;
 	IF_SELINUX(security_context_t sid = NULL;)
+#if ENABLE_SMACK
+	char xattr[SMACKBUFFSIZE];
+	int i;
+#endif
 
 	if ((all_fmt & FOLLOW_LINKS) || force_follow) {
 #if ENABLE_SELINUX
@@ -295,6 +303,11 @@ static struct dnode *my_stat(const char
 			 getfilecon(fullname, &sid);
 		}
 #endif
+#if ENABLE_SMACK
+		i = smack_from_file(fullname, xattr, sizeof(xattr), 1);
+		if (i < 0)
+			xattr[0] = '\0';
+#endif
 		if (stat(fullname, &dstat)) {
 			bb_simple_perror_msg(fullname);
 			exit_code = EXIT_FAILURE;
@@ -306,6 +319,11 @@ static struct dnode *my_stat(const char
 			lgetfilecon(fullname, &sid);
 		}
 #endif
+#if ENABLE_SMACK
+		i = smack_from_file(fullname, xattr, sizeof(xattr), 0);
+		if (i < 0)
+			xattr[0] = '\0';
+#endif
 		if (lstat(fullname, &dstat)) {
 			bb_simple_perror_msg(fullname);
 			exit_code = EXIT_FAILURE;
@@ -318,6 +336,7 @@ static struct dnode *my_stat(const char
 	cur->name = name;
 	cur->dstat = dstat;
 	IF_SELINUX(cur->sid = sid;)
+	IF_SMACK(strncpy(cur->xattr, xattr, sizeof(xattr));)
 	return cur;
 }
 
@@ -685,6 +704,10 @@ static NOINLINE unsigned list_single(con
 		freecon(dn->sid);
 	}
 #endif
+#if ENABLE_SMACK
+	if (all_fmt & LIST_CONTEXT)
+		column += printf("%-23s ", dn->xattr);
+#endif
 	if (all_fmt & LIST_FILENAME) {
 #if ENABLE_FEATURE_LS_COLOR
 		if (show_color) {
@@ -753,6 +776,7 @@ static void showfiles(struct dnode **dn,
 		}
 		column_width += tabstops +
 			IF_SELINUX( ((all_fmt & LIST_CONTEXT) ? 33 : 0) + )
+			IF_SMACK( ((all_fmt & LIST_CONTEXT) ? 24 : 0) + )
 				((all_fmt & LIST_INO) ? 8 : 0) +
 				((all_fmt & LIST_BLOCKS) ? 5 : 0);
 		ncols = (int) (terminal_width / column_width);
diff -uprN busybox-1.17.1/coreutils/stat.c busybox-1.17.1-smack/coreutils/stat.c
--- busybox-1.17.1/coreutils/stat.c	2010-07-05 19:25:53.000000000 -0700
+++ busybox-1.17.1-smack/coreutils/stat.c	2011-08-18 17:01:04.060191320 -0700
@@ -18,6 +18,7 @@
 #define OPT_TERSE       (1 << 1)
 #define OPT_DEREFERENCE (1 << 2)
 #define OPT_SELINUX     (1 << 3)
+#define OPT_SMACK       (1 << 4)
 
 #if ENABLE_FEATURE_STAT_FORMAT
 typedef bool (*statfunc_ptr)(const char *, const char *);
@@ -154,7 +155,8 @@ static void printfs(char *pformat, const
 /* print statfs info */
 static void FAST_FUNC print_statfs(char *pformat, const char m,
 		const char *const filename, const void *data
-		IF_SELINUX(, security_context_t scontext))
+		IF_SELINUX(, security_context_t scontext)
+		IF_SMACK(, char *smack))
 {
 	const struct statfs *statfsbuf = data;
 	if (m == 'n') {
@@ -192,6 +194,10 @@ static void FAST_FUNC print_statfs(char
 	} else if (m == 'C' && (option_mask32 & OPT_SELINUX)) {
 		printfs(pformat, scontext);
 # endif
+#if ENABLE_SMACK
+	} else if (m == 'C' && (option_mask32 & OPT_SMACK)) {
+		printfs(pformat, smack);
+#endif
 	} else {
 		strcatc(pformat, 'c');
 		printf(pformat, m);
@@ -201,7 +207,8 @@ static void FAST_FUNC print_statfs(char
 /* print stat info */
 static void FAST_FUNC print_stat(char *pformat, const char m,
 		const char *const filename, const void *data
-		IF_SELINUX(, security_context_t scontext))
+		IF_SELINUX(, security_context_t scontext)
+		IF_SMACK(, char *smack))
 {
 #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
 	struct stat *statbuf = (struct stat *) data;
@@ -296,6 +303,10 @@ static void FAST_FUNC print_stat(char *p
 	} else if (m == 'C' && (option_mask32 & OPT_SELINUX)) {
 		printfs(pformat, scontext);
 # endif
+#if ENABLE_SMACK
+	} else if (m == 'C' && (option_mask32 & OPT_SMACK)) {
+		printfs(pformat, smack);
+#endif
 	} else {
 		strcatc(pformat, 'c');
 		printf(pformat, m);
@@ -304,9 +315,10 @@ static void FAST_FUNC print_stat(char *p
 
 static void print_it(const char *masterformat,
 		const char *filename,
-		void FAST_FUNC (*print_func)(char*, char, const char*, const void* IF_SELINUX(, security_context_t scontext)),
+		void FAST_FUNC (*print_func)(char*, char, const char*, const void* IF_SELINUX(, security_context_t scontext) IF_SMACK(, char *smack)),
 		const void *data
-		IF_SELINUX(, security_context_t scontext))
+		IF_SELINUX(, security_context_t scontext)
+		IF_SMACK(, char *smack) )
 {
 	/* Create a working copy of the format string */
 	char *format = xstrdup(masterformat);
@@ -349,7 +361,7 @@ static void print_it(const char *masterf
 			break;
 		default:
 			/* Completes "%<modifiers>" with specifier and printfs */
-			print_func(dest, *p, filename, data IF_SELINUX(,scontext));
+			print_func(dest, *p, filename, data IF_SELINUX(,scontext) IF_SMACK(,smack) );
 			break;
 		}
 	}
@@ -383,6 +395,18 @@ static bool do_statfs(const char *filena
 		}
 	}
 #endif
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+
+	if (option_mask32 & OPT_SMACK) {
+		int i = option_mask32 & OPT_DEREFERENCE;
+
+		if (smack_from_file(filename, smack, sizeof(smack), i) < 0) {
+			bb_perror_msg("%s", filename);
+			return 0;
+		}
+	}
+#endif
 	if (statfs(filename, &statfsbuf) != 0) {
 		bb_perror_msg("can't read file system information for '%s'", filename);
 		return 0;
@@ -390,7 +414,7 @@ static bool do_statfs(const char *filena
 
 #if ENABLE_FEATURE_STAT_FORMAT
 	if (format == NULL) {
-# if !ENABLE_SELINUX
+# if !ENABLE_SELINUX && !ENABLE_SMACK
 		format = (option_mask32 & OPT_TERSE
 			? "%n %i %l %t %s %b %f %a %c %d\n"
 			: "  File: \"%n\"\n"
@@ -400,9 +424,9 @@ static bool do_statfs(const char *filena
 			  "Inodes: Total: %-10c Free: %d");
 # else
 		format = (option_mask32 & OPT_TERSE
-			? (option_mask32 & OPT_SELINUX ? "%n %i %l %t %s %b %f %a %c %d %C\n":
+			? (option_mask32 & (OPT_SELINUX | OPT_SMACK) ? "%n %i %l %t %s %b %f %a %c %d %C\n":
 			"%n %i %l %t %s %b %f %a %c %d\n")
-			: (option_mask32 & OPT_SELINUX ?
+			: (option_mask32 & (OPT_SELINUX | OPT_SMACK) ?
 			"  File: \"%n\"\n"
 			"    ID: %-8i Namelen: %-7l Type: %T\n"
 			"Block size: %-10s\n"
@@ -415,9 +439,9 @@ static bool do_statfs(const char *filena
 			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
 			"Inodes: Total: %-10c Free: %d\n")
 			);
-# endif /* SELINUX */
+# endif /* SELINUX or Smack */
 	}
-	print_it(format, filename, print_statfs, &statfsbuf IF_SELINUX(, scontext));
+	print_it(format, filename, print_statfs, &statfsbuf IF_SELINUX(, scontext) IF_SMACK(, smack) );
 #else /* FEATURE_STAT_FORMAT */
 	format = (option_mask32 & OPT_TERSE
 		? "%s %llx %lu "
@@ -433,7 +457,7 @@ static bool do_statfs(const char *filena
 	else
 		printf("Type: %s\n", human_fstype(statfsbuf.f_type));
 
-# if !ENABLE_SELINUX
+# if !ENABLE_SELINUX && !ENABLE_SMACK
 	format = (option_mask32 & OPT_TERSE
 		? "%lu %llu %llu %llu %llu %llu\n"
 		: "Block size: %-10lu\n"
@@ -448,8 +472,8 @@ static bool do_statfs(const char *filena
 	       (unsigned long long) statfsbuf.f_ffree);
 # else
 	format = (option_mask32 & OPT_TERSE
-		? (option_mask32 & OPT_SELINUX ? "%lu %llu %llu %llu %llu %llu %C\n" : "%lu %llu %llu %llu %llu %llu\n")
-		: (option_mask32 & OPT_SELINUX
+		? (option_mask32 & (OPT_SELINUX | OPT_SMACK) ? "%lu %llu %llu %llu %llu %llu %C\n" : "%lu %llu %llu %llu %llu %llu\n")
+		: (option_mask32 & (OPT_SELINUX | OPT_SMACK)
 			?	"Block size: %-10lu\n"
 				"Blocks: Total: %-10llu Free: %-10llu Available: %llu\n"
 				"Inodes: Total: %-10llu Free: %llu"
@@ -496,6 +520,18 @@ static bool do_stat(const char *filename
 		}
 	}
 #endif
+#if ENABLE_SMACK
+	char smack[SMACKBUFFSIZE];
+
+	if (option_mask32 & OPT_SMACK) {
+		int i = option_mask32 & OPT_DEREFERENCE;
+
+		if (smack_from_file(filename, smack, sizeof(smack), i) < 0) {
+			bb_perror_msg("%s", filename);
+			return 0;
+		}
+	}
+#endif
 	if ((option_mask32 & OPT_DEREFERENCE ? stat : lstat) (filename, &statbuf) != 0) {
 		bb_perror_msg("can't stat '%s'", filename);
 		return 0;
@@ -503,7 +539,7 @@ static bool do_stat(const char *filename
 
 #if ENABLE_FEATURE_STAT_FORMAT
 	if (format == NULL) {
-# if !ENABLE_SELINUX
+#if !ENABLE_SELINUX && !ENABLE_SMACK
 		if (option_mask32 & OPT_TERSE) {
 			format = "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o";
 		} else {
@@ -526,12 +562,12 @@ static bool do_stat(const char *filename
 		}
 # else
 		if (option_mask32 & OPT_TERSE) {
-			format = (option_mask32 & OPT_SELINUX ?
+			format = (option_mask32 & (OPT_SELINUX | OPT_SMACK) ?
 				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o %C\n":
 				  "%n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %o\n");
 		} else {
 			if (S_ISBLK(statbuf.st_mode) || S_ISCHR(statbuf.st_mode)) {
-				format = (option_mask32 & OPT_SELINUX ?
+				format = (option_mask32 & (OPT_SELINUX | OPT_SMACK) ?
 					  "  File: %N\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					  "Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
@@ -546,7 +582,7 @@ static bool do_stat(const char *filename
 					  "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					  "Access: %x\n" "Modify: %y\n" "Change: %z\n");
 			} else {
-				format = (option_mask32 & OPT_SELINUX ?
+				format = (option_mask32 & (OPT_SELINUX | OPT_SMACK) ?
 					  "  File: %N\n"
 					  "  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					  "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
@@ -562,11 +598,14 @@ static bool do_stat(const char *filename
 		}
 # endif
 	}
-	print_it(format, filename, print_stat, &statbuf IF_SELINUX(, scontext));
+	print_it(format, filename, print_stat, &statbuf IF_SELINUX(, scontext) IF_SMACK(, smack) );
 #else	/* FEATURE_STAT_FORMAT */
 	if (option_mask32 & OPT_TERSE) {
+#if !ENABLE_SELINUX && !ENABLE_SMACK
+		printf("%s %llu %llu %lx %lu %lu %llx %llu %lu %lx %lx %lu %lu %lu %lu\n"
+#else
 		printf("%s %llu %llu %lx %lu %lu %llx %llu %lu %lx %lx %lu %lu %lu %lu"
-		       IF_NOT_SELINUX("\n"),
+#endif
 		       filename,
 		       (unsigned long long) statbuf.st_size,
 		       (unsigned long long) statbuf.st_blocks,
@@ -589,6 +628,12 @@ static bool do_stat(const char *filename
 		else
 			bb_putchar('\n');
 # endif
+#if ENABLE_SMACK
+		if (option_mask32 & OPT_SMACK)
+			printf(" %lc\n", smack);
+		else
+			bb_putchar('\n');
+#endif
 	} else {
 		char *linkname = NULL;
 
@@ -632,6 +677,9 @@ static bool do_stat(const char *filename
 # if ENABLE_SELINUX
 		printf("   S_Context: %lc\n", *scontext);
 # endif
+#if ENABLE_SMACK
+		printf("   Smack: %lc\n", smack);
+#endif
 		printf("Access: %s\n" "Modify: %s\n" "Change: %s\n",
 		       human_time(statbuf.st_atime),
 		       human_time(statbuf.st_mtime),
@@ -653,6 +701,7 @@ int stat_main(int argc UNUSED_PARAM, cha
 	opt_complementary = "-1"; /* min one arg */
 	opts = getopt32(argv, "ftL"
 		IF_SELINUX("Z")
+		IF_SMACK("Z")
 		IF_FEATURE_STAT_FORMAT("c:", &format)
 	);
 	if (opts & OPT_FILESYS) /* -f */
diff -uprN busybox-1.17.1/findutils/find.c busybox-1.17.1-smack/findutils/find.c
--- busybox-1.17.1/findutils/find.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/findutils/find.c	2011-08-18 17:39:38.790218576 -0700
@@ -223,6 +223,13 @@
 //config:	help
 //config:	  Support the 'find -context' option for matching security context.
 //config:
+//config:config FEATURE_FIND_SMACK
+//config:	bool "Enable -smack: Smack label matching"
+//config:	default n
+//config:	depends on FIND && SMACK
+//config:	help
+//config:	  Support the 'find -smack' option for matching Smack label.
+//config:
 //config:config FEATURE_FIND_LINKS
 //config:	bool "Enable -links: link count matching"
 //config:	default y
@@ -268,6 +275,7 @@ IF_FEATURE_FIND_INUM(   ACTS(inum,  ino_
 IF_FEATURE_FIND_USER(   ACTS(user,  uid_t uid;))
 IF_FEATURE_FIND_SIZE(   ACTS(size,  char size_char; off_t size;))
 IF_FEATURE_FIND_CONTEXT(ACTS(context, security_context_t context;))
+IF_FEATURE_FIND_SMACK(  ACTS(smack,  const char *smack;))
 IF_FEATURE_FIND_PAREN(  ACTS(paren, action ***subexpr;))
 IF_FEATURE_FIND_PRUNE(  ACTS(prune))
 IF_FEATURE_FIND_DELETE( ACTS(delete))
@@ -573,6 +581,17 @@ ACTF(context)
 	return rc == 0;
 }
 #endif
+#if ENABLE_FEATURE_FIND_SMACK
+ACTF(smack)
+{
+	char smack[SMACKBUFFSIZE];
+
+	if (smack_from_file(fileName, smack, SMACKBUFFSIZE,
+		(G.recurse_flags & ACTION_FOLLOWLINKS) ? 1 : 0) < 0)
+		return FALSE;
+	return strcmp(ap->smack, smack) == 0;
+}
+#endif
 #if ENABLE_FEATURE_FIND_LINKS
 ACTF(links)
 {
@@ -704,6 +723,7 @@ static action*** parse_params(char **arg
 	IF_FEATURE_FIND_GROUP(  PARM_group     ,)
 	IF_FEATURE_FIND_SIZE(   PARM_size      ,)
 	IF_FEATURE_FIND_CONTEXT(PARM_context   ,)
+	IF_FEATURE_FIND_SMACK(	PARM_smack     ,)
 	IF_FEATURE_FIND_LINKS(  PARM_links     ,)
 	};
 
@@ -738,6 +758,7 @@ static action*** parse_params(char **arg
 	IF_FEATURE_FIND_GROUP(  "-group\0"  )
 	IF_FEATURE_FIND_SIZE(   "-size\0"   )
 	IF_FEATURE_FIND_CONTEXT("-context\0")
+	IF_FEATURE_FIND_SMACK(  "-smack\0"  )
 	IF_FEATURE_FIND_LINKS(  "-links\0"  )
 	                         ;
 
@@ -1028,6 +1049,13 @@ static action*** parse_params(char **arg
 				bb_simple_perror_msg(arg1);
 		}
 #endif
+#if ENABLE_FEATURE_FIND_SMACK
+		else if (parm == PARM_smack) {
+			action_smack *ap;
+			ap = ALLOC_ACTION(smack);
+			ap->smack = arg1;
+		}
+#endif
 #if ENABLE_FEATURE_FIND_LINKS
 		else if (parm == PARM_links) {
 			action_links *ap;
@@ -1115,6 +1143,9 @@ static action*** parse_params(char **arg
 //usage:	IF_FEATURE_FIND_CONTEXT(
 //usage:     "\n	-context	File has specified security context"
 //usage:	)
+//usage:	IF_FEATURE_FIND_CONTEXT(
+//usage:     "\n	-smack		File has specified Smack label"
+//usage:	)
 //usage:	IF_FEATURE_FIND_EXEC(
 //usage:     "\n	-exec CMD ARG ;	Run CMD with all instances of {} replaced by the"
 //usage:     "\n			matching files"
diff -uprN busybox-1.17.1/include/applets.src.h busybox-1.17.1-smack/include/applets.src.h
--- busybox-1.17.1/include/applets.src.h	2010-07-24 15:12:43.000000000 -0700
+++ busybox-1.17.1-smack/include/applets.src.h	2011-08-18 11:40:15.809964682 -0700
@@ -279,6 +279,7 @@ IF_MV(APPLET(mv, _BB_DIR_BIN, _BB_SUID_D
 IF_NAMEIF(APPLET(nameif, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_NC(APPLET(nc, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_NETSTAT(APPLET(netstat, _BB_DIR_BIN, _BB_SUID_DROP))
+IF_NEWSMACK(APPLET(newsmack, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_NICE(APPLET(nice, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_NMETER(APPLET(nmeter, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_NOHUP(APPLET(nohup, _BB_DIR_USR_BIN, _BB_SUID_DROP))
@@ -356,6 +357,9 @@ IF_SHA512SUM(APPLET_ODDNAME(sha512sum, m
 IF_SHOWKEY(APPLET(showkey, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_SLATTACH(APPLET(slattach, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_SLEEP(APPLET_NOFORK(sleep, sleep, _BB_DIR_BIN, _BB_SUID_DROP, sleep))
+IF_SMACKCIPSO(APPLET(smackcipso, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
+IF_SMACKENABLED(APPLET(smackenabled, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
+IF_SMACKLOAD(APPLET(smackload, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, _BB_DIR_USR_BIN, _BB_SUID_DROP, softlimit))
 IF_SORT(APPLET_NOEXEC(sort, sort, _BB_DIR_USR_BIN, _BB_SUID_DROP, sort))
 IF_SPLIT(APPLET(split, _BB_DIR_USR_BIN, _BB_SUID_DROP))
diff -uprN busybox-1.17.1/include/libbb.h busybox-1.17.1-smack/include/libbb.h
--- busybox-1.17.1/include/libbb.h	2010-07-24 15:12:43.000000000 -0700
+++ busybox-1.17.1-smack/include/libbb.h	2011-08-18 11:54:34.569974792 -0700
@@ -52,6 +52,12 @@
 #include <selinux/flask.h>
 #include <selinux/av_permissions.h>
 #endif
+#if ENABLE_SMACK
+#define	SMACKBUFFSIZE	24
+#define	SMACKATTR		"security.SMACK64"
+#define	SMACKFLOOR		"_"
+#define	SMACKSTAR		"*"
+#endif
 #if ENABLE_LOCALE_SUPPORT
 # include <locale.h>
 #else
@@ -1183,6 +1189,16 @@ extern void selinux_preserve_fcontext(in
 #endif
 extern void selinux_or_die(void) FAST_FUNC;
 
+#if ENABLE_SMACK
+extern int smack_from_file(const char *path, char *result, int len, int follow);
+extern int smack_from_proc(const int pid, char *result, int len);
+extern int smack_to_file(const char *path, const char *smack, int follow);
+extern int smack_to_proc(const int pid, const char *smack);
+extern int smack_user_default(const char *user, char *result, int len);
+extern int smack_user_allowed(const char *user, const char *smack);
+extern int smack_user_add(const char *user, const char *smack);
+#endif
+
 /* setup_environment:
  * if chdir pw->pw_dir: ok: else if to_tmp == 1: goto /tmp else: goto / or die
  * if clear_env = 1: cd(pw->pw_dir), clear environment, then set
@@ -1391,6 +1407,7 @@ typedef struct procps_status_t {
 	char *argv0;
 	char *exe;
 	IF_SELINUX(char *context;)
+	IF_SMACK(char smack[SMACKBUFFSIZE];)
 	/* Everything below must contain no ptrs to malloc'ed data:
 	 * it is memset(0) for each process in procps_scan() */
 	unsigned long vsz, rss; /* we round it to kbytes */
@@ -1453,6 +1470,7 @@ enum {
 				|| ENABLE_SESTATUS
 				),
 	PSSCAN_CONTEXT  = (1 << 17) * ENABLE_SELINUX,
+	PSSCAN_SMACK    = (1 << 17) * ENABLE_SMACK,
 	PSSCAN_START_TIME = 1 << 18,
 	PSSCAN_CPU      = (1 << 19) * ENABLE_FEATURE_TOP_SMP_PROCESS,
 	PSSCAN_NICE     = (1 << 20) * ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS,
@@ -1574,6 +1592,9 @@ extern const char bb_path_group_file[];
 extern const char bb_path_motd_file[];
 extern const char bb_path_wtmp_file[];
 extern const char bb_dev_null[];
+#if ENABLE_SMACK
+extern const char bb_path_smack_user[];
+#endif
 extern const char bb_busybox_exec_path[];
 extern const char *bb_busybox_exec_paths[];
 /* util-linux manpage says /sbin:/bin:/usr/sbin:/usr/bin,
diff -uprN busybox-1.17.1/include/usage.src.h busybox-1.17.1-smack/include/usage.src.h
--- busybox-1.17.1/include/usage.src.h	2010-07-24 15:12:43.000000000 -0700
+++ busybox-1.17.1-smack/include/usage.src.h	2011-08-18 12:10:12.649985839 -0700
@@ -1764,6 +1764,9 @@ INSERT
 	IF_SELINUX( \
      "\n	-Z	Print the security context" \
 	) \
+	IF_SMACK( \
+     "\n	-Z	Print the Smack label" \
+	) \
      "\n	-u	Print user ID" \
      "\n	-g	Print group ID" \
      "\n	-G	Print supplementary group IDs" \
@@ -2982,6 +2985,11 @@ INSERT
      "\n	-p	Display PID/Program name for sockets" \
 	)
 
+#define newsmack_trivial_usage \
+     "label [COMMAND [ARG] ...]"
+#define newsmack_full_usage \
+     "Run a program or shell with the specified Smack label" \
+
 #define nmeter_trivial_usage \
        "format_string"
 #define nmeter_full_usage "\n\n" \
@@ -3303,7 +3311,7 @@ INSERT
 
 #else /* !ENABLE_DESKTOP */
 
-#if !ENABLE_SELINUX && !ENABLE_FEATURE_PS_WIDE
+#if !ENABLE_SELINUX && !ENABLE_FEATURE_PS_WIDE && !ENABLE_SMACK
 #define USAGE_PS "\nThis version of ps accepts no options"
 #else
 #define USAGE_PS "\nOptions:"
@@ -3317,6 +3325,9 @@ INSERT
 	IF_SELINUX( \
      "\n	-Z	Show selinux context" \
 	) \
+	IF_SMACK( \
+     "\n	-Z	Show Smack label" \
+	) \
 	IF_FEATURE_PS_WIDE( \
      "\n	w	Wide output" \
 	)
@@ -3845,6 +3856,17 @@ INSERT
        "$ sleep 1d 3h 22m 8s\n" \
        "[98528 second delay results]\n")
 
+#define smackcipso_trivial_usage
+#define smackcipso_full_usage \
+       "Read and set Smack CIPSO mappings from the standard input"
+
+#define smackenabled_trivial_usage
+#define smackenabled_full_usage
+
+#define smackload_trivial_usage
+#define smackload_full_usage \
+       "Read and set Smack access rules from the standard input"
+
 #define sort_trivial_usage \
        "[-nru" \
 	IF_FEATURE_SORT_BIG("gMcszbdfimSTokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR") \
@@ -3982,6 +4004,9 @@ INSERT
 	IF_SELINUX( \
      "\n	-Z	Print security context" \
 	) \
+	IF_SMACK( \
+     "\n	-Z	Print Smack label" \
+	) \
 	IF_FEATURE_STAT_FORMAT( \
        "\n\nValid format sequences for files:\n" \
        " %a	Access rights in octal\n" \
@@ -4019,6 +4044,9 @@ INSERT
 	IF_SELINUX( \
        " %C	Security context in selinux\n" \
 	) \
+	IF_SMACK( \
+       " %C	Smack label\n" \
+	) \
        " %i	File System ID in hex\n" \
        " %l	Maximum length of filenames\n" \
        " %n	File name\n" \
diff -uprN busybox-1.17.1/libbb/Kbuild.src busybox-1.17.1-smack/libbb/Kbuild.src
--- busybox-1.17.1/libbb/Kbuild.src	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/libbb/Kbuild.src	2011-08-18 15:10:58.330113541 -0700
@@ -126,6 +126,7 @@ lib-$(CONFIG_FEATURE_UTMP) += utmp.o
 # A mix of optimizations (why build stuff we know won't be used)
 # and objects which may fail to build (SELinux on selinux-less system)
 lib-$(CONFIG_SELINUX) += selinux_common.o
+lib-$(CONFIG_SMACK) += smack_common.o
 lib-$(CONFIG_FEATURE_MTAB_SUPPORT) += mtab.o
 lib-$(CONFIG_UNICODE_SUPPORT) += unicode.o
 lib-$(CONFIG_FEATURE_CHECK_NAMES) += die_if_bad_username.o
diff -uprN busybox-1.17.1/libbb/messages.c busybox-1.17.1-smack/libbb/messages.c
--- busybox-1.17.1/libbb/messages.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/libbb/messages.c	2011-08-17 15:27:12.889107702 -0700
@@ -43,6 +43,9 @@ const char bb_path_shadow_file[] ALIGN1
 const char bb_path_group_file[] ALIGN1 = "/etc/group";
 const char bb_path_gshadow_file[] ALIGN1 = "/etc/gshadow";
 const char bb_path_motd_file[] ALIGN1 = "/etc/motd";
+#if ENABLE_SMACK
+const char bb_path_smack_user[] ALIGN1 = "/etc/smack/user";
+#endif
 const char bb_dev_null[] ALIGN1 = "/dev/null";
 const char bb_busybox_exec_path[] ALIGN1 = CONFIG_BUSYBOX_EXEC_PATH;
 const char *bb_busybox_exec_paths[] ALIGN1 = {
diff -uprN busybox-1.17.1/libbb/procps.c busybox-1.17.1-smack/libbb/procps.c
--- busybox-1.17.1/libbb/procps.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/libbb/procps.c	2011-08-17 15:27:12.909107701 -0700
@@ -240,6 +240,12 @@ procps_status_t* FAST_FUNC procps_scan(p
 				sp->context = NULL;
 		}
 #endif
+#if ENABLE_SMACK
+		if (flags & PSSCAN_SMACK) {
+			if (smack_from_proc(sp->pid, sp->smack, SMACKBUFFSIZE) < 0)
+				strcpy(sp->smack, "?");
+		}
+#endif
 
 		filename_tail = filename + sprintf(filename, "/proc/%u/", pid);
 
diff -uprN busybox-1.17.1/libbb/smack_common.c busybox-1.17.1-smack/libbb/smack_common.c
--- busybox-1.17.1/libbb/smack_common.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/libbb/smack_common.c	2011-08-18 17:17:53.730203208 -0700
@@ -0,0 +1,178 @@
+/*
+ * libbb/smack_common.c
+ *   -- common Smack utility functions
+ *
+ * Copyright 2007 Casey Schaufler <casey@schaufler-ca.com>
+ */
+#include "libbb.h"
+#include <sys/xattr.h>
+
+#define	SMACKPROCPATH	"/proc/%d/attr/current"
+#define SMACKUSERFILE	"/etc/smack/user"
+#define SMACKFILELINE	256
+
+int smack_from_file(const char *path, char *result, int len, int follow)
+{
+	char buffer[SMACKBUFFSIZE];
+	int rc;
+
+	if (follow)
+		rc = getxattr(path, SMACKATTR, buffer, SMACKBUFFSIZE - 1);
+	else
+		rc = lgetxattr(path, SMACKATTR, buffer, SMACKBUFFSIZE - 1);
+
+	if (rc < 0)
+		return rc;
+
+	buffer[rc] = '\0';
+	if (strlen(buffer) > len)
+		return -EINVAL;
+
+	strcpy(result, buffer);
+	return rc;
+}
+
+int smack_from_proc(const int pid, char *result, int len)
+{
+	char path[SMACKFILELINE];
+	char buffer[SMACKFILELINE];
+	int fd;
+	int i;
+
+	sprintf(path, SMACKPROCPATH, (pid < 0) ? getpid() : pid);
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return -EACCES;
+
+	i = read(fd, buffer, SMACKFILELINE);
+	close(fd);
+
+	if (i <= 0 || i >= len)
+		return -ERANGE;
+	buffer[i] = '\0';
+	strcpy(result, buffer);
+	return 0;
+}
+
+int smack_to_file(const char *path, const char *smack, int follow)
+{
+	if (follow)
+		return setxattr(path, SMACKATTR, smack, strlen(smack)+1, 0);
+	return lsetxattr(path, SMACKATTR, smack, strlen(smack)+1, 0);
+}
+
+int smack_to_proc(const int pid, const char *smack)
+{
+	char path[SMACKFILELINE];
+	int fd;
+	int i;
+	int slen;
+
+	slen = strlen(smack) + 1;
+	if (slen >= SMACKBUFFSIZE)
+		return -ERANGE;
+
+	sprintf(path, SMACKPROCPATH, (pid < 0) ? getpid() : pid);
+
+	fd = open(path, O_RDWR);
+	if (fd < 0)
+		return -EACCES;
+
+	i = write(fd, smack, slen);
+	close(fd);
+
+	if (i != slen)
+		return -EINVAL;
+	return 0;
+}
+
+int smack_user_default(const char *user, char *result, int len)
+{
+	char line[SMACKFILELINE];
+	char ruser[SMACKFILELINE];
+	char rsmack[SMACKFILELINE];
+	FILE *fp;
+
+	fp = fopen(bb_path_smack_user, "r");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+		if (sscanf(line, "%s %s", ruser, rsmack) != 2)
+			continue;
+		if (strcmp(ruser, user) != 0)
+			continue;
+		if (strlen(rsmack) >= len)
+			return -ERANGE;
+		strcpy(result, rsmack);
+		return 0;
+	}
+	return -ENOENT;
+}
+
+int smack_user_allowed(const char *user, const char *smack)
+{
+	char line[SMACKFILELINE];
+	char *ruser;
+	char *rsmack;
+	FILE *fp;
+	int rc = 1;
+
+	fp = fopen(SMACKUSERFILE, "r");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (rc == 1 && fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+
+		ruser = strtok(line, " \t\n");
+		if (ruser == NULL)
+			continue;
+
+		if (strcmp(ruser, user) != 0)
+			continue;
+
+		while (rc == 1 && (rsmack = strtok(NULL, " \t\n")) != NULL) {
+			if (strcmp(rsmack, smack) == 0 || strcmp(rsmack, "+") == 0)
+				rc = 0;
+		}
+	}
+	fclose(fp);
+	return (rc == 1) ? -ENOENT : rc;
+}
+
+int smack_user_add(const char *user, const char *smack)
+{
+	char line[SMACKFILELINE];
+	char *ruser;
+	FILE *fp;
+	int rc = 0;
+
+	fp = fopen(SMACKUSERFILE, "a+");
+	if (fp == NULL)
+		return -ENOENT;
+
+	while (fgets(line, SMACKFILELINE, fp) != NULL) {
+		if (line[0] == '#' || line[0] == '\n')
+			continue;
+
+		ruser = strtok(line, " \t\n");
+		if (ruser == NULL)
+			continue;
+
+		if (strcmp(ruser, user) == 0) {
+			rc = -EEXIST;
+			break;
+		}
+	}
+
+	if (rc == 0)
+		fprintf(fp, "%s %s\n", user, smack);
+
+	fclose(fp);
+	return rc;
+}
diff -uprN busybox-1.17.1/loginutils/adduser.c busybox-1.17.1-smack/loginutils/adduser.c
--- busybox-1.17.1/loginutils/adduser.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/loginutils/adduser.c	2011-08-17 15:27:12.909107701 -0700
@@ -112,6 +112,7 @@ int adduser_main(int argc UNUSED_PARAM,
 	const char *usegroup = NULL;
 	char *p;
 	unsigned opts;
+	IF_SMACK(const char *smack = SMACKSTAR;)
 
 #if ENABLE_FEATURE_ADDUSER_LONG_OPTIONS
 	applet_long_options = adduser_longopts;
@@ -130,10 +131,10 @@ int adduser_main(int argc UNUSED_PARAM,
 	/* disable interactive passwd for system accounts */
 	opt_complementary = "=1:SD:u+";
 	if (sizeof(pw.pw_uid) == sizeof(int)) {
-		opts = getopt32(argv, "h:g:s:G:DSHu:", &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup, &pw.pw_uid);
+		opts = getopt32(argv, "h:g:s:G:DSHu:" IF_SMACK("L:"), &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup, &pw.pw_uid IF_SMACK(, &smack) );
 	} else {
 		unsigned uid;
-		opts = getopt32(argv, "h:g:s:G:DSHu:", &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup, &uid);
+		opts = getopt32(argv, "h:g:s:G:DSHu:" IF_SMACK("L:"), &pw.pw_dir, &pw.pw_gecos, &pw.pw_shell, &usegroup, &uid IF_SMACK(, &smack) );
 		if (opts & OPT_UID) {
 			pw.pw_uid = uid;
 		}
@@ -220,6 +221,14 @@ int adduser_main(int argc UNUSED_PARAM,
 			bb_simple_perror_msg(pw.pw_dir);
 		}
 	}
+#if ENABLE_SMACK
+	if (smack_user_add(pw.pw_name, smack) < 0)
+		bb_error_msg("cannot add user smack entry");
+	if (strtok(smack, " \t") != NULL)
+		if (smack_to_file(pw.pw_dir, smack, 0) != 0)
+			bb_error_msg("cannot set smack on home directory");
+#endif
+
 
 	if (!(opts & OPT_DONT_SET_PASS)) {
 		/* interactively set passwd */
diff -uprN busybox-1.17.1/loginutils/login.c busybox-1.17.1-smack/loginutils/login.c
--- busybox-1.17.1/loginutils/login.c	2010-07-24 15:12:43.000000000 -0700
+++ busybox-1.17.1-smack/loginutils/login.c	2011-08-17 15:27:12.909107701 -0700
@@ -218,6 +218,7 @@ int login_main(int argc UNUSED_PARAM, ch
 	struct passwd pwdstruct;
 	char pwdbuf[256];
 #endif
+	IF_SMACK(char smack[SMACKBUFFSIZE];)
 
 	username[0] = '\0';
 	signal(SIGALRM, alarm_handler);
@@ -376,6 +377,13 @@ int login_main(int argc UNUSED_PARAM, ch
 		die_if_nologin();
 
 	IF_SELINUX(initselinux(username, full_tty, &user_sid));
+#if ENABLE_SMACK
+	if (smack_user_default(pw->pw_name, smack, SMACKBUFFSIZE) < 0)
+		strcpy(smack, SMACKFLOOR);
+	if (smack_to_proc(-1, smack) < 0)
+		bb_perror_msg_and_die("cannot set smack");
+#endif
+
 
 	/* Try these, but don't complain if they fail.
 	 * _f_chown is safe wrt race t=ttyname(0);...;chown(t); */
diff -uprN busybox-1.17.1/loginutils/su.c busybox-1.17.1-smack/loginutils/su.c
--- busybox-1.17.1/loginutils/su.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/loginutils/su.c	2011-08-18 15:13:07.830115065 -0700
@@ -44,6 +44,7 @@ int su_main(int argc UNUSED_PARAM, char
 	const char *tty;
 	char user_buf[64];
 	const char *old_user;
+	IF_SMACK(char smack[SMACKBUFFSIZE];)
 
 	flags = getopt32(argv, "mplc:s:", &opt_command, &opt_shell);
 	//argc -= optind;
@@ -129,6 +130,13 @@ int su_main(int argc UNUSED_PARAM, char
 			+ (!(flags & SU_OPT_mp) * SETUP_ENV_CHANGEENV),
 			pw);
 	IF_SELINUX(set_current_security_context(NULL);)
+#if ENABLE_SMACK
+	if (smack_from_proc(-1, smack, SMACKBUFFSIZE) < 0)
+		bb_error_msg_and_die("cannot identify process smack");
+	if (smack_user_allowed(pw->pw_name, smack) < 0)
+		bb_error_msg_and_die("new usr not allowed current smack");
+#endif
+
 
 	/* Never returns */
 	run_shell(opt_shell, flags & SU_OPT_l, opt_command, (const char**)argv);
diff -uprN busybox-1.17.1/loginutils/sulogin.c busybox-1.17.1-smack/loginutils/sulogin.c
--- busybox-1.17.1/loginutils/sulogin.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/loginutils/sulogin.c	2011-08-17 15:27:12.909107701 -0700
@@ -26,6 +26,7 @@ int sulogin_main(int argc UNUSED_PARAM,
 	char buffer[256];
 	struct spwd spw;
 #endif
+	IF_SMACK(char smack[SMACKBUFFSIZE];)
 
 	logmode = LOGMODE_BOTH;
 	openlog(applet_name, 0, LOG_AUTH);
@@ -97,6 +98,11 @@ int sulogin_main(int argc UNUSED_PARAM,
 	bb_info_msg("System Maintenance Mode");
 
 	IF_SELINUX(renew_current_security_context());
+#if ENABLE_SMACK
+	if (smack_to_proc(-1, SMACKFLOOR) < 0)
+		bb_error_msg("login incorrect");
+#endif
+
 
 	shell = getenv("SUSHELL");
 	if (!shell)
diff -uprN busybox-1.17.1/Makefile busybox-1.17.1-smack/Makefile
--- busybox-1.17.1/Makefile	2010-07-24 15:13:44.000000000 -0700
+++ busybox-1.17.1-smack/Makefile	2011-08-17 15:27:12.909107701 -0700
@@ -482,6 +482,7 @@ libs-y		:= \
 		runit/ \
 		selinux/ \
 		shell/ \
+		smack/ \
 		sysklogd/ \
 		util-linux/ \
 		util-linux/volume_id/ \
diff -uprN busybox-1.17.1/miscutils/crond.c busybox-1.17.1-smack/miscutils/crond.c
--- busybox-1.17.1/miscutils/crond.c	2010-07-24 15:12:43.000000000 -0700
+++ busybox-1.17.1-smack/miscutils/crond.c	2011-08-17 15:27:12.909107701 -0700
@@ -906,6 +906,7 @@ static void RunJob(const char *user, Cro
 {
 	struct passwd *pas;
 	pid_t pid;
+	IF_SMACK(char smack[SMACKBUFFSIZE];)
 
 	/* prepare things before vfork */
 	pas = getpwnam(user);
@@ -919,6 +920,16 @@ static void RunJob(const char *user, Cro
 	pid = vfork();
 	if (pid == 0) {
 		/* CHILD */
+#if ENABLE_SMACK
+		if (smack_user_default(user, smack, SMACKBUFFSIZE) < 0) {
+			crondlog("\024user %s default smack unknown\n", user);
+			exit(0);
+		}
+		if (smack_to_proc(-1, smack) < 0) {
+			crondlog("\024user %s smack unsettable\n", user);
+			exit(0);
+		}
+#endif
 		/* change running state to the user in question */
 		ChangeUser(pas);
 		if (DebugOpt) {
diff -uprN busybox-1.17.1/miscutils/crontab.c busybox-1.17.1-smack/miscutils/crontab.c
--- busybox-1.17.1/miscutils/crontab.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/miscutils/crontab.c	2011-08-17 15:27:12.909107701 -0700
@@ -77,6 +77,10 @@ int crontab_main(int argc UNUSED_PARAM,
 	int fd;
 	int src_fd;
 	int opt_ler;
+#if ENABLE_SMACK
+	char psmack[SMACKBUFFSIZE];
+	char dsmack[SMACKBUFFSIZE];
+#endif
 
 	/* file [opts]     Replace crontab from file
 	 * - [opts]        Replace crontab from stdin
@@ -120,6 +124,15 @@ int crontab_main(int argc UNUSED_PARAM,
 	if ((opt_ler - 1) & opt_ler) /* more than one bit set? */
 		bb_show_usage();
 
+#if ENABLE_SMACK
+	if (smack_user_default(pas->pw_name, dsmack, SMACKBUFFSIZE) < 0)
+		bb_perror_msg_and_die("user default smack unknown");
+	if (smack_from_proc(-1, psmack, SMACKBUFFSIZE) < 0)
+		bb_perror_msg_and_die("user default smack unknown");
+	if (strcmp(dsmack, psmack) != 0)
+		bb_perror_msg_and_die("current smack is not default smack");
+#endif
+
 	/* Read replacement file under user's UID/GID/group vector */
 	src_fd = STDIN_FILENO;
 	if (!opt_ler) { /* Replace? */
diff -uprN busybox-1.17.1/procps/ps.c busybox-1.17.1-smack/procps/ps.c
--- busybox-1.17.1/procps/ps.c	2010-07-05 19:25:54.000000000 -0700
+++ busybox-1.17.1-smack/procps/ps.c	2011-08-18 17:28:10.070210464 -0700
@@ -25,7 +25,12 @@ enum { MAX_WIDTH = 2*1024 };
 #if ENABLE_SELINUX
 #define SELINUX_O_PREFIX "label,"
 #define DEFAULT_O_STR    (SELINUX_O_PREFIX "pid,user" IF_FEATURE_PS_TIME(",time") ",args")
-#else
+#endif
+#if ENABLE_SMACK
+#define SMACK_O_PREFIX "label,"
+#define DEFAULT_O_STR    (SMACK_O_PREFIX "pid,user" IF_FEATURE_PS_TIME(",time") ",args")
+#endif
+#if !ENABLE_SELINUX && !ENABLE_SMACK
 #define DEFAULT_O_STR    ("pid,user" IF_FEATURE_PS_TIME(",time") ",args")
 #endif
 
@@ -288,6 +293,13 @@ static void func_label(char *buf, int si
 }
 #endif
 
+#if ENABLE_SMACK
+static void func_label(char *buf, int size, const procps_status_t *ps)
+{
+	safe_strncpy(buf, ps->smack[0] ? ps->smack : "?", size+1);
+}
+#endif
+
 /*
 static void func_nice(char *buf, int size, const procps_status_t *ps)
 {
@@ -327,6 +339,9 @@ static const ps_out_t out_spec[] = {
 #if ENABLE_SELINUX
 	{ 35                 , "label" ,"LABEL"  ,func_label ,PSSCAN_CONTEXT },
 #endif
+#if ENABLE_SMACK
+	{ 24                 , "label" ,"LABEL"  ,func_label ,PSSCAN_SMACK },
+#endif
 };
 
 static ps_out_t* new_out_t(void)
@@ -516,6 +531,12 @@ int ps_main(int argc UNUSED_PARAM, char
 			strcpy(default_o, DEFAULT_O_STR + sizeof(SELINUX_O_PREFIX)-1);
 		} else
 #endif
+#if ENABLE_SMACK
+		if (!(opt & 1)) {
+			/* no -Z : do not show LABEL */
+			strcpy(default_o, DEFAULT_O_STR + sizeof(SMACK_O_PREFIX) -1);
+		} else
+#endif
 		{
 			strcpy(default_o, DEFAULT_O_STR);
 		}
@@ -557,17 +578,17 @@ int ps_main(int argc UNUSED_PARAM, char
 			| PSSCAN_STATE | PSSCAN_VSZ | PSSCAN_COMM;
 	unsigned terminal_width IF_NOT_FEATURE_PS_WIDE(= 79);
 	enum {
-		OPT_Z = (1 << 0) * ENABLE_SELINUX,
-		OPT_T = (1 << ENABLE_SELINUX) * ENABLE_FEATURE_SHOW_THREADS,
+		OPT_Z = (1 << 0) * (ENABLE_SELINUX | ENABLE_SMACK),
+		OPT_T = (1 << (ENABLE_SELINUX | ENABLE_SMACK)) * ENABLE_FEATURE_SHOW_THREADS,
 	};
 	int opts = 0;
 	/* If we support any options, parse argv */
-#if ENABLE_SELINUX || ENABLE_FEATURE_SHOW_THREADS || ENABLE_FEATURE_PS_WIDE
+#if ENABLE_SELINUX || ENABLE_FEATURE_SHOW_THREADS || ENABLE_FEATURE_PS_WIDE || ENABLE_SMACK
 # if ENABLE_FEATURE_PS_WIDE
 	/* -w is a bit complicated */
 	int w_count = 0;
 	opt_complementary = "-:ww";
-	opts = getopt32(argv, IF_SELINUX("Z")IF_FEATURE_SHOW_THREADS("T")"w", &w_count);
+	opts = getopt32(argv, IF_SELINUX("Z")IF_SMACK("Z")IF_FEATURE_SHOW_THREADS("T")"w", &w_count);
 	/* if w is given once, GNU ps sets the width to 132,
 	 * if w is given more than once, it is "unlimited"
 	 */
@@ -582,7 +603,7 @@ int ps_main(int argc UNUSED_PARAM, char
 # else
 	/* -w is not supported, only -Z and/or -T */
 	opt_complementary = "-";
-	opts = getopt32(argv, IF_SELINUX("Z")IF_FEATURE_SHOW_THREADS("T"));
+	opts = getopt32(argv, IF_SELINUX("Z")IF_SMACK("Z")IF_FEATURE_SHOW_THREADS("T"));
 # endif
 #endif
 
@@ -593,6 +614,13 @@ int ps_main(int argc UNUSED_PARAM, char
 		puts("  PID CONTEXT                          STAT COMMAND");
 	} else
 #endif
+#if ENABLE_SMACK
+	if (opts & OPT_Z) {
+		psscan_flags = PSSCAN_PID | PSSCAN_SMACK
+				| PSSCAN_STATE | PSSCAN_COMM;
+		puts("  PID CONTEXT                          STAT COMMAND");
+	} else
+#endif
 	{
 		puts("  PID USER       VSZ STAT COMMAND");
 	}
@@ -611,6 +639,14 @@ int ps_main(int argc UNUSED_PARAM, char
 					p->state);
 		} else
 #endif
+#if ENABLE_SMACK
+		if (psscan_flags & PSSCAN_SMACK) {
+			len = printf("%5u %-24.24s %s  ",
+					p->pid,
+					p->smack ? p->smack : "unknown",
+					p->state);
+		} else
+#endif
 		{
 			const char *user = get_cached_username(p->uid);
 			//if (p->vsz == 0)
diff -uprN busybox-1.17.1/smack/Config.src busybox-1.17.1-smack/smack/Config.src
--- busybox-1.17.1/smack/Config.src	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/Config.src	2011-08-18 11:19:44.669950186 -0700
@@ -0,0 +1,40 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Smack Utilities"
+	depends on SMACK
+
+INSERT
+
+config SMACKLOAD
+	bool "smackload"
+	default n
+	depends on SMACK
+	help
+	  Enable support to load Smack access rules.
+
+config SMACKCIPSO
+	bool "smackcipso"
+	default n
+	depends on SMACK
+	help
+	  Enable support to specify Smack CIPSO mappings.
+
+config NEWSMACK
+	bool "newsmack"
+	default n
+	depends on SMACK
+	help
+	  Enable support to run command with specified Smack label.
+
+config SMACKENABLED
+	bool "smackenabled"
+	default n
+	depends on SMACK
+	help
+	  Enable support for this command to be used within shell scripts
+	  to determine if smack is enabled.
+
+endmenu
diff -uprN busybox-1.17.1/smack/Kbuild.src busybox-1.17.1-smack/smack/Kbuild.src
--- busybox-1.17.1/smack/Kbuild.src	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/Kbuild.src	2011-08-19 13:22:11.301054005 -0700
@@ -0,0 +1,14 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2005 by Erik Andersen <andersen@codepoet.org>
+# Copyright (C) 2007 by KaiGai Kohei <kaigai@kaigai.gr.jp>
+#
+# Licensed under the GPL v2, see the file LICENSE in this tarball.
+
+INSERT
+
+lib-y:=
+lib-$(CONFIG_NEWSMACK)		+= newsmack.o
+lib-$(CONFIG_SMACKLOAD)		+= smackload.o
+lib-$(CONFIG_SMACKCIPSO)	+= smackcipso.o
+lib-$(CONFIG_SMACKENABLED)	+= smackenabled.o
diff -uprN busybox-1.17.1/smack/newsmack.c busybox-1.17.1-smack/smack/newsmack.c
--- busybox-1.17.1/smack/newsmack.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/newsmack.c	2011-08-17 15:27:12.909107701 -0700
@@ -0,0 +1,61 @@
+/*
+ * newsmack label [ command [ arg ] ... ]
+ *
+ * Port to busybox: Casey Schaufler <casey@schaufler-ca.com>
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ */
+
+#include "libbb.h"
+
+int newsmack_main(int argc, char **argv);
+int newsmack_main(int argc, char **argv)
+{
+	struct passwd *pwd;
+	char *newargv[256]; /* yes, I know */
+	char *smack;
+	int i;
+	int newargc;
+
+	if (argc <= 1)
+		bb_error_msg_and_die("No smack value specified");
+
+	smack = argv[1];
+
+	/*
+	 * Start a shell if no command is specified
+	 */
+	if (argc == 2) {
+		fprintf(stderr, "%s: start a shell at \"%s\"\n",
+			argv[0], smack);
+		newargv[0] = strdup("sh");
+		newargv[1] = NULL;
+	} else {
+		for (newargc = 0, i = 2; i < argc; newargc++, i++)
+			newargv[newargc] = argv[i];
+		newargv[newargc] = NULL;
+	}
+
+	/*
+	 * Verify the user is allowed the Smack label
+	 */
+	pwd = getpwuid(getuid());
+	if (pwd == NULL)
+		bb_error_msg_and_die("User name not obtained");
+	if (smack_user_allowed(pwd->pw_name, smack) != 0)
+		bb_error_msg_and_die("User not allowed this smack label");
+	/*
+	 * Set the process label.
+	 */
+	i = smack_to_proc(-1, smack);
+	if (i < 0)
+		bb_error_msg_and_die("Cannot set smack");
+
+	/*
+	 * Do the exec
+	 */
+	execvp(newargv[0], newargv);
+
+	bb_error_msg_and_die("%s: exec failure.", newargv[0]);
+}
diff -uprN busybox-1.17.1/smack/smackcipso.c busybox-1.17.1-smack/smack/smackcipso.c
--- busybox-1.17.1/smack/smackcipso.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/smackcipso.c	2011-08-17 15:27:12.909107701 -0700
@@ -0,0 +1,119 @@
+/*
+ * smackcipso - properly format smack access cipsos for
+ * loading into the kernel by writing to /smack/cipso.
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation, version 2.
+ *
+ * Authors:
+ *	Casey Schaufler <casey@schaufler-ca.com>
+ *	Ahmed S. Darwish <darwish.07@gmail.com>
+ *
+ */
+/*
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+*/
+#include "libbb.h"
+
+#define LSIZE 23
+#define NSIZE 4
+#define MAXCATNUM 239
+#define MAXCATVAL 63
+#define MAXLEVEL 255
+
+int smackcipso_main(int argc, char **argv);
+int smackcipso_main(int argc, char **argv)
+{
+	int status = EXIT_SUCCESS;
+	int cipsofd;
+	char line[512];
+	char cipso[LSIZE + NSIZE + NSIZE + (NSIZE * MAXCATNUM)];
+	char cats[MAXCATNUM+1][NSIZE+1];
+	char *cp;
+	int level;
+	int cat;
+	int catcount;
+	int i;
+	int err;
+
+	cipsofd = open("/smack/cipso", O_RDWR);
+	if (cipsofd < 0)
+		bb_error_msg_and_die("failed opening /smack/cipso");
+
+	while (fgets(line, sizeof(line), stdin) != NULL) {
+		catcount = 0;
+		err = 0;
+
+		if ((cp = strchr(line, '\n')) == NULL) {
+			fprintf(stderr, "missing newline \"%s\"\n", line);
+			continue;
+		}
+		*cp = '\0';
+		cp = strtok(line, " \t");
+		if (cp == NULL) {
+			fprintf(stderr, "Empty line: \"%s\"\n", line);
+			continue;
+		}
+		sprintf(cipso, "%-23s ", line);
+		if (strlen(cipso) != 24) {
+			fprintf(stderr, "Bad label starting: \"%s\"\n", line);
+			continue;
+		}
+		cp = strtok(NULL, " \t");
+		if (cp == NULL) {
+			fprintf(stderr, "Missing level: \"%s\"\n", line);
+			continue;
+		}
+		if (!isdigit(*cp)) {
+			fprintf(stderr, "Bad level: \"%s\"\n", cp);
+			continue;
+		}
+		level = atoi(cp);
+		if (level > MAXLEVEL) {
+			fprintf(stderr, "Bad level: \"%s\"\n", cp);
+			continue;
+		}
+		sprintf(cipso+LSIZE+1, "%-4d", level);
+
+		cp = strtok(NULL, " \t");
+		for (i = 0; cp != NULL; cp = strtok(NULL, " \t"), i++) {
+			if (!isdigit(*cp)) {
+				fprintf(stderr, "Bad category \"%s\"\n", cp);
+				err = 1;
+				break;
+			}
+			cat = atoi(cp);
+			if (i >= MAXCATNUM) {
+				fprintf(stderr, "Maximum number of categories"
+					"exceeded \"%d\"\n", i);
+				err = 1;
+				break;
+			}
+			if (cat > MAXCATVAL) {
+				fprintf(stderr, "Bad category \"%s\"\n", cp);
+				err = 1;
+				break;
+			}
+			sprintf(cats[i], "%-4d", cat);
+		}
+		if (err)
+			continue;
+
+		sprintf(cipso+LSIZE+1+NSIZE, "%-4d", i);
+		while (i > 0)
+			strcat(cipso, cats[--i]);
+		err = write(cipsofd, cipso, strlen(cipso));
+		if (err < 0)
+			perror("writing /smack/cipso");
+	}
+	return status;
+}
diff -uprN busybox-1.17.1/smack/smackenabled.c busybox-1.17.1-smack/smack/smackenabled.c
--- busybox-1.17.1/smack/smackenabled.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/smackenabled.c	2011-08-17 15:27:12.909107701 -0700
@@ -0,0 +1,17 @@
+/*
+ * smackenabled
+ *
+ * Port to BusyBox  Casey Schaufler <casey@schaufler-ca.com
+ *
+ */
+#include "libbb.h"
+
+int smackenabled_main(int argc, char **argv);
+int smackenabled_main(int argc, char **argv)
+{
+	char buffer[80];
+
+	if (smack_from_file("/", buffer, sizeof(buffer), 0) < 0)
+		return 0;
+	return 1;
+}
diff -uprN busybox-1.17.1/smack/smackload.c busybox-1.17.1-smack/smack/smackload.c
--- busybox-1.17.1/smack/smackload.c	1969-12-31 16:00:00.000000000 -0800
+++ busybox-1.17.1-smack/smack/smackload.c	2011-08-17 15:27:12.909107701 -0700
@@ -0,0 +1,93 @@
+/*
+ * smackload - properly format smack access rules for
+ * loading into the kernel by writing to /smack/load.
+ *
+ * Copyright (C) 2007 Casey Schaufler <casey@schaufler-ca.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation, version 2.
+ *
+ * Author:
+ *	Casey Schaufler <casey@schaufler-ca.com>
+ */
+/*
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+*/
+#include "libbb.h"
+
+#define LSIZE 23
+#define ASIZE 4
+
+int smackload_main(int argc, char **argv);
+int smackload_main(int argc, char **argv)
+{
+	int status = EXIT_SUCCESS;
+	int loadfd;
+	char line[80];
+	char rule[LSIZE + LSIZE + ASIZE + 3];
+	char subject[LSIZE+1];
+	char object[LSIZE+1];
+	char accesses[ASIZE+1];
+	char real[ASIZE+1];
+	char *cp;
+	int i;
+	int err;
+
+	loadfd = open("/smack/load", O_RDWR);
+	if (loadfd < 0)
+		bb_error_msg_and_die("failed opening /smack/load");
+
+	while (fgets(line, 80, stdin) != NULL) {
+		err = 0;
+		if ((cp = strchr(line, '\n')) != NULL)
+			*cp = '\0';
+		if (sscanf(line,"%23s %23s %4s",subject,object,accesses) != 3) 
+			err = 1;
+		else {
+			strcpy(real, "----");
+			for (i = 0;
+			     i < ASIZE && accesses[i] != '\0' && err == 0;
+			     i++) {
+				switch (accesses[i]) {
+				case 'r':
+				case 'R':
+					real[0] = 'r';
+					break;
+				case 'w':
+				case 'W':
+					real[1] = 'w';
+					break;
+				case 'x':
+				case 'X':
+					real[2] = 'x';
+					break;
+				case 'a':
+				case 'A':
+					real[3] = 'a';
+					break;
+				case '\0':
+				case '-':
+					break;
+				default:
+					err = 1;
+					break;
+				}
+			}
+		}
+		if (err == 0) {
+			sprintf(rule, "%-23s %-23s %4s", subject,object,real);
+			err = write(loadfd, rule, LSIZE + LSIZE + ASIZE + 2);
+			if (err < 0)
+				perror("writing /smack/load");
+		}
+		else
+			fprintf(stderr, "Bad input line \"%s\"\n", line);
+	}
+	return status;
+}
